#A.py

from B import D

class C:pass


#B.py
from A import C

class D:pass


运行A.py会产生错误，为什么？
1. 当运行 A.py 的时候，会先执行from B import D，B是不在sys.path里面的，所以需要一个新建一个module B，再执行B里面的内容填充__dict__;
2. 当在执行B里面的内容的时候，会先执行from A import C，A也是不在sys.path里面的，所以需要新建一个moduleA，执行A里面的内容；
3. 因为之前已经新建了module B，但是后面的import D的时候，D还没来的及创建，找不到，就会报错。

#赋值 深拷贝 浅拷贝
赋值：对对象的引用，就是换了一个标签，打印id一样  

a=[1,2,3]
b=a
print(id(a))
print(id(b))

打印结果为：
4435400072
4435400072

#浅拷贝:指创建一个新的对象，其内容是原对象中元素的引用。（拷贝组合对象，不拷贝子对象）
a=[1,2,3,4,5]
b=list(a)
print(id(a))
print(id(b))

for x,y in zip(a,b):
    print(id(x),id(y))

打印结果为：
4361500040
4361664200
4358331760 4358331760
4358331792 4358331792
4358331824 4358331824
4358331856 4358331856
4358331888 4358331888

#a 浅拷贝得到 b，a 和 b 指向内存中不同的 list 对象，所以当第一次打印a,b两个的id的时候，是不一样的，但它们的元素却指向相同的 int 对象。

#深拷贝：通过copy模块中的deepcopy函数

