#A.py

from B import D

class C:pass


#B.py
from A import C

class D:pass


运行A.py会产生错误，为什么？
1. 当运行 A.py 的时候，会先执行from B import D，B是不在sys.path里面的，所以需要一个新建一个module B，再执行B里面的内容填充__dict__;
2. 当在执行B里面的内容的时候，会先执行from A import C，A也是不在sys.path里面的，所以需要新建一个moduleA，执行A里面的内容；
3. 因为之前已经新建了module B，但是后面的import D的时候，D还没来的及创建，找不到，就会报错。

#相对导入和绝对导入
绝对导入
import pandas
import pandas from DataFrame

相对导入



#赋值 深拷贝 浅拷贝
赋值：对对象的引用，就是换了一个标签，打印id一样  

a=[1,2,3]
b=a
print(id(a))
print(id(b))

打印结果为：
4435400072
4435400072

#浅拷贝:指创建一个新的对象，其内容是原对象中元素的引用。（拷贝组合对象，不拷贝子对象）
a=[1,2,3,4,5]
b=list(a)
print(id(a))
print(id(b))

for x,y in zip(a,b):
    print(id(x),id(y))

打印结果为：
4361500040
4361664200
4358331760 4358331760
4358331792 4358331792
4358331824 4358331824
4358331856 4358331856
4358331888 4358331888

#a 浅拷贝得到 b，a 和 b 指向内存中不同的 list 对象，所以当第一次打印a,b两个的id的时候，是不一样的，但它们的元素却指向相同的 int 对象。

#深拷贝：通过copy模块中的deepcopy函数

#raw_input在python2.7版本中是内置函数，input在python3.6版本中是内置函数

#字符编码问题
字符集：系统支持的抽象字符的集合
字符编码：计算机内部只支持二进制，把字符存储为二进制的数据，用什么规则，这就是对字符进行编码

编码和解码：
任何信息，存放在存储介质中时，都是二进制流（比特流):
编码过程： 字符转换成二进制流表示的过程(encode);
解码过程： 二进制流转换成字符的过程(decode);
编码规则： 编码和解码过程中遵循的规则，例如GBK编码，UTF-8编码;



例如(linux)：
a='中文'
b=u'中文'


#简明python，动手做一个东西 (最原始版本)
import zipfile
import os
import time

filepath= r'C:\\Users\\Hymn\\Desktop\\caiwu'

f = zipfile.ZipFile('caiwu'+time.strftime('%Y%m%d')+'.zip', 'w')
for root , dirs, files in os.walk(filepath):
    for r in  files:
        f.write(filepath+'\\'+r)
f.close()
